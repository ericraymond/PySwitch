/**
 * Main application controller
 */
class Controller {

    static PYSWITCH_VERSION = "2.4.5";                           // Version of PySwitch this emulator is designed to run with
    static VERSION = Controller.PYSWITCH_VERSION + ".12";        // PySwitch Emulator Version

    ui = null;                  // User Interface implementation
    routing = null;             // sammy.js router

    midi = null;                // MIDI handler
    device = null;              // Device handler (Controller, like Midi Captain)
    client = null;              // Client handler (like Kemper Profiler)
    presets = null;             // Presets handler
    pyswitch = null;            // PySwitch runner (in browser)

    currentConfig = null;       // Currently loaded Configuration instance
    
    /**
     * Options:
     * {
     *     // UI options:
     *     containerElementSelector: "body",       DOM Selector for the container DOM element the ui should be built in 
     *                                             (optional, default: "body")
     * 
     *     // Python options:
     *     domNamespace: "pyswitch",               ID prefix for access to DOM elements from Python code. All elements generated by python code will 
     *                                             be prefixed with this. Optional, default is "pyswitch".
     *                                             Explanation: Python code searches its elements via ID selectors. To avoid conflicts, this option has to be present.
     * 
     *     updateIntervalMillis: 20,               Tick interval in milliseconds. On CircuitPython, the program does as much ticks as it can (in a while True loop),
     *                                             which in a browser woult block all user interaction, so the ticks are triggered in intervals. Optional, default is 20.
     * 
     *     exploreMode: False,                     Boot PySwitch into explore mode
     * }
     */
    constructor(options = {}) {
        // Defaults
        if (!options.containerElementSelector) {
            options.containerElementSelector = "body";
        }
        if (!options.domNamespace) {
            options.domNamespace = "pyswitch";
        }
        if (!options.updateIntervalMillis) {
            options.updateIntervalMillis = 20;
        }

        options.errorHandler = this;
        
        // Set up handlers
        this.ui = new PySwitchUI(this, options);

        this.midi = new MidiHandler();

        const that = this;
        options.messageHandler = {
            message: function(msg, type) {
                that.ui.notifications.message(msg, type);
            }
        }

        this.pyswitch = new PySwitchRunner(options, options.domNamespace + "-device");    
        this.device = new DeviceController(this);
        this.client = new ClientController(this);
        this.presets = new Presets();
    }

    /**
     * Run the app.
     */
    async run() {
        try {
            try {
                // Initialize MIDI
                await this.midi.init();

            } catch (e) {
                // This means there is no Web MIDI access. In this case, you can still use the emulator but without MIDI access.
                this.handle(e);
            }

            // Initialize UI (settings panel etc.)        
            await this.ui.build();

            // Routing handler: Runs routing. see Routing.js for the callbacks which in turn call this controller again.
            this.routing = new Routing(this);
            this.routing.run();

        } catch (e) {
            this.handle(e);
        }
    }

    /**
     * Handle exceptions
     */
    handle(e) {
        this.ui.message(e, "E");
    }

    /**
     * Scans for controllers and navigate to load its configuration
     */
    async scanControllers() {
        console.log("Scanning ports for MidiBridges...");

        const that = this;
        await this.device.scan(
            // onSuccess
            function(connection) {
                setTimeout(function() {
                    // Detach the bridge (scanning will just call a redirect which creates its own bridge)
                    that.device.bridge.detach(connection.bridge);

                    // Redirect to the found controller's URL
                    that.routing.call(that.getControllerUrl(connection.name));
                }, 0);
            },

            // onFailure
            function() {
                setTimeout(function() {
                    // Redirect to the default config
                    that.routing.call(that.getControllerUrl("pyswitch-default"));
                }, 0);
            }
        );
    }

    /**
     * Run PySwitch with a specific Configuration instance.
     */
    async loadConfiguration(config) {
        this.ui.reset();

        this.ui.resetDirtyState();

        if (this.currentConfig) await this.currentConfig.destroy();
        this.currentConfig = null;

        // Initialize PySwitch (this starts Pyodide and copies all necessary sources to the Emscripten virtual file system)
        this.ui.progress(0.1, "Initialize emulator");

        await this.pyswitch.init();

        // Init configuration
        this.ui.progress(0.4, "Initialize configuration");

        await config.init(this.pyswitch);

        // Get PySwitch version
        this.ui.progress(0.4, "Initialize UI");        

        // Initialize client (scan for devices)
        this.ui.progress(0.5, "Initialize client device");
        
        await this.client.init(config);

        const that = this;
        this.pyswitch.setProtocolStateCallback(function(state) {
            switch(state) {
                case 10:  // Offline
                    break;
                case 20:  // Running
                    that.ui.clientButton.setState(ClientConnectionButton.STATE_CONNECTED);
                    break;
            }
        });

        // Stop the engine
        this.ui.progress(0.6, "Stop engine");

        await this.pyswitch.stop();

        // Generate parser UI, show name of config, CSS classes etc.
        this.ui.progress(0.7, "Setup UI");

        await this.ui.applyConfig(config);

        // Run local PySwitch with the config
        this.ui.progress(0.8, "Run PySwitch");

        await this.pyswitch.run(config);

        this.ui.progress(1);
        this.currentConfig = config;

        this.ui.message("Loaded " + (await config.name()), "S");
    }

    /**
     * Restarts the current configuration
     * 
     * {
     *      message: Set to override the default success message. If set to "none", no message is issued at all.
     *      changeCallback: If set, this is called when the engine is down, to apply changes to the configuration in between.
     * }
     */
    async restart(options = {}) {
        this.ui.reset();
        
        if (!this.currentConfig) {
            console.warn("No config to restart");
            return;
        }

        // Hide all inputs and LEDs etc.
        await this.ui.frontend.reset();

        // After the frontend changes, we must let some time pass for the UI to flush.
        const that = this;
        setTimeout(async function() {
            try {
                // Stop the engine
                await that.pyswitch.stop();

                // If requested, do some changes (or whatever else) before the config is 
                // applied to the UI and started again
                if (options.changeCallback) {
                    await options.changeCallback();
                }

                // Recreate UI
                await that.ui.applyConfig(that.currentConfig);

                // Restart configuration
                await that.pyswitch.run(that.currentConfig);

                if (options.message != "none") {
                    that.ui.message(options.message ? options.message : ("Reloaded " + (await that.currentConfig.name())), "S");
                }

            } catch (e) {
                that.handle(e);
            }
        }, 10);
    }

    /**
     * Returns a href for the passed path on the current port
     */
    getControllerUrl(portName) {
        if (!portName) portName = this.device.portName();
        return encodeURI("controller/" + portName);
    }
}